import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from typing import List

path = r"C:\Users\User\Desktop\Ahmad\Stages\SurfMetrics\Git\Passation\update_db\esg_filter\data" + "\\"

class GS_model:
    def __init__(self, lang:str = "en", threshold:float = 0.7):
        '''
        # Info 
        -----
        Initialize Mean_model

        # Parameters
        -----
        threshhold: float, the threshhold above which the 
        similarity is relevant (if the cosine similarity 
        of two arrays is less than the threshhold, then the
        two arrays are not similar)
        '''
        self.lang = lang
        self.threshold = threshold
        self.e_orth = np.load(path + "e_orth_embeddings.npy")
        self.s_orth = np.load(path + "s_orth_embeddings.npy")
        self.g_orth = np.load(path + "g_orth_embeddings.npy")
        self.esg_orth = np.load(path + "esg_orth_embeddings.npy")

    def fit(self, embeddings: np.ndarray, mode:int = 0) -> List[int]:
        '''
        # Info 
        -----
        Find the esg class for each embedding
        # Parameters
        -----
        embeddings: numpy array the embeddings extracted from tweets
        model: integer = 0 (try e_dict, s_dict, g_dict) or 1 (group the three dictionnaries into one)
        
        # Returns
        -----
        It returns a List containing the class for each embedding
        '''
        if mode == 0:
            l = []
            for a in embeddings:
                a1 = self._proj(a, self.e_orth)
                a2 = self._proj(a, self.s_orth)
                a3 = self._proj(a, self.g_orth)
                l+=[cosine_similarity(a.reshape(1,-1), np.vstack([a1, a2, a3]))]
            return [np.argmax(e) if np.max(e)>self.threshold else -1 for e in l]
        elif mode == 1:
            l = []
            for a in embeddings:
                a_F = self._proj(a, self.esg_orth)
                l+=[cosine_similarity(a.reshape(1,-1), a.reshape(1,-1))]
            return [1 if np.max(e)>self.threshold else -1 for e in l]

    def _proj(self, a: np.array, base: np.ndarray) -> np.ndarray:
        '''
        # Info
        ---
        This function will find the orthogonal projection of the
        vector generated by the word on the plane generated by our
        dictionnary.

        # Parameters
        ---
        a: embedding array
        base: array of arrays that constitutes the base

        # Returns
        ---
        returns the orthogonal projetcion of a.
        '''

        a_F = np.zeros(len(a))
        for e in base:
            a_F = np.add(a_F, np.multiply((e@a),e))
        return a_F