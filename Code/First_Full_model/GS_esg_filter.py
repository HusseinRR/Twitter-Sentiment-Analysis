import constants as c

##Embedder
from sentence_transformers import SentenceTransformer, util
from transformers import AutoTokenizer, AutoModel, BertTokenizer
import torch
import typing as t
import pandas as pd


MODEL_NAME = 'paraphrase-multilingual-mpnet-base-v2'
labels = ['E','S','G']
embedder = SentenceTransformer(MODEL_NAME)


def vect(text:str) -> torch.tensor:
    ''' 
    # Info
    ---
     This function transforms text to tensors

    # Parameters
    ---
    Only text

    # Results
    ---
    Tensor dim = 0

    '''
    return embedder.encode(text, convert_to_tensor=True)


def dics(lang):
  if lang == "fr":
    return c.fr_dic
  else:
    return c.en_dic


class GS_model:
    def __init__(self, lang: str):
        self.lang = lang
        self.Dics = dics(lang)

    def gs(self, X: torch.tensor) -> torch.tensor:
        '''
        # Info
        ---
        This is Gramschmidt function, it finds an orthogonal 
        base for a random base

        # Parameters
        ---
        It takes in input an list of tensors corresponding to 
        the base of our space

        # Returns
        ---
        It returns the orthogonalisation of this base as a list
        of tensors too
        '''

        Y = []
        for e in X:
            proj_e = torch.zeros(len(e))
            for inY in Y :
                a = torch.mul((inY@e) ,inY )
                proj_e = torch.add(proj_e,a)
            e = torch.subtract(e,proj_e)
            e = torch.mul(e, 1/(torch.norm(e)))
            Y.append(e)
        return torch.stack(Y)

    def forward(self, word: str, orth: torch.tensor) -> torch.tensor:
        '''
        # Info
        ---
        This function will find the orthogonal projection of the
        vector generated by the word on the plane generated by our
        dictionnary. Then it will calculate the cosine angle between 
        the vector and the plane

        # Parameters
        ---
        It takes as parameters a string and the list of our orthonormalised
        base. 

        # Returns
        ---
        We get in return the cosine similarity between the vector 
        and its projection on the plane
        '''
        a = vect(word)
        a_F = torch.zeros(len(a))
        for e in orth:
            a_F = torch.add(a_F, torch.mul((e@a),e))
        return util.cos_sim(a, a_F) 

    def label(self, word: str, orth:torch.tensor, threshold: float) -> str:
        if self.forward(word, orth)>threshold:
            return 'True'
        else:
            return 'False'



def gs_esg(text:str, lang:str='en', threshold:float=0.722):
    filter = GS_model(lang)
    E_plane = filter.gs(vect(filter.Dics[0]))
    S_plane = filter.gs(vect(filter.Dics[1]))
    G_plane = filter.gs(vect(filter.Dics[2]))
    label_dic = {
        'E': filter.forward(text, E_plane),
        'S': filter.forward(text, S_plane),
        'G': filter.forward(text, G_plane)
        }
    sort_orders = sorted(label_dic.items(), key=lambda x: x[1], reverse=True)
    if sort_orders[0][1]<threshold:
        return 'None'
    else:
        return sort_orders[0][0]