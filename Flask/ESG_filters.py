
import constants as c

##Embedder
from sentence_transformers import SentenceTransformer, util
from transformers import AutoTokenizer, AutoModel, BertTokenizer
import torch
import typing as t
import pandas as pd


MODEL_NAME = 'paraphrase-multilingual-mpnet-base-v2'
labels = ['E','S','G']
embedder = SentenceTransformer(MODEL_NAME)

def vect(text:str) -> torch.tensor:
  ''' 
  # Info
  ---
  This function transforms text to tensors

  # Parameters
  ---
  Only text

  # Results
  Tensor dim = 0

  '''
  return embedder.encode(text, convert_to_tensor=True)


def dics(lang):
  if lang == "fr":
    return c.fr_dic
  else:
    return c.en_dic


class Mean_model:
    def __init__(self, lang: str, threshold: float):
      self.lang = lang
      self.threshold = threshold
      self.Dics = dics(lang)
      self.E_vector = torch.mean(vect(self.Dics[0]), axis = 0)
      self.S_vector = torch.mean(vect(self.Dics[1]), axis = 0)
      self.G_vector = torch.mean(vect(self.Dics[2]), axis = 0)

    def esg_similarity(self, text: str) -> torch.tensor:
      '''
      # Info 
      -----
      This Function calculates the similarity 
      between the text and each one of the
      three ESG categories

      # Parameters
      -----
      It only take a text parameter
      # Returns
      ----
      It returns a torch vector containing the 
      cosine similarity for earch of the three 
      categories
      '''
      a = vect(text)
      output = []
      output.append(util.cos_sim(a, self.E_vector))
      output.append(util.cos_sim(a, self.S_vector))
      output.append(util.cos_sim(a, self.G_vector))
      return torch.cat(output, dim=1)[0]

    def esg_class(self,text:str) -> str:
      '''
      # Info 
      -----
      This Function finds the ESG class of
      the text

      # Parameters
      -----
      It only takes a text parameter
      # Returns
      ----
      It returns the ESG class as a string
      '''
      x = self.esg_similarity(text)
      k = torch.argmax(x)
      if x[k] > self.threshold:
        return labels[k]
      else:
        return 'N'
  
    def esg_filter(self,df : pd.DataFrame) -> pd.DataFrame:
      '''
      # Info
      ----
      This function removes the None-ESG tweets from
      the dataframe and adds the ESG label of each 
      tweet to the dataframe

      # Parameters
      ----
      Pandas dataframe

      # Returns
      ---
      the new modified dataframe
      '''

      df['ESG class'] = df['clean text'].apply(lambda x: self.esg_class(self,x))
      df = df[~df['ESG class'].str.contains("N")]
      df= df.reset_index(drop=True)
      return  df


filter_en = Mean_model("en", 0.3)
filter_fr = Mean_model("fr", 0.3)

def mean_esg(text:str, lang:str):
      if lang == "fr":
        filter = filter_fr
      else:
        filter = filter_en
      return filter.esg_class(text)




class GS_model:
    def gs(self, X: torch.tensor) -> torch.tensor:
        '''
        # Info
        ---
        This is Gramschmidt function, it finds an orthogonal 
        base for a random base

        # Parameters
        ---
        It takes in input an list of tensors corresponding to 
        the base of our space

        # Returns
        ---
        It returns the orthogonalisation of this base as a list
        of tensors too
        '''

        Y = []
        for e in X:
            proj_e = torch.zeros(len(e))
            for inY in Y :
                a = torch.mul((inY@e) ,inY )
                proj_e = torch.add(proj_e,a)
            e = torch.subtract(e,proj_e)
            e = torch.mul(e, 1/(torch.norm(e)))
            Y.append(e)
        return torch.stack(Y)

    def forward(self, word: str, orth: torch.tensor) -> torch.tensor:
        '''
        # Info
        ---
        This function will find the orthogonal projection of the
        vector generated by the word on the plane generated by our
        dictionnary. Then it will calculate the cosine angle between 
        the vector and the plane

        # Parameters
        ---
        It takes as parameters a string and the list of our orthonormalised
        base. 

        # Returns
        ---
        We get in return the cosine similarity between the vector 
        and its projection on the plane
        '''
        a = vect(word)
        a_F = torch.zeros(len(a))
        for e in orth:
            a_F = torch.add(a_F, torch.mul((e@a),e))
        return util.cos_sim(a, a_F) 

    def label(self, word: str, orth:torch.tensor, threshold: float) -> str:
        if self.forward(word, orth)>threshold:
            return 'True'
        else:
            return 'False'




filter = GS_model()
Dics = dics("fr")
E_plane_fr = filter.gs(vect(Dics[0]))
S_plane_fr = filter.gs(vect(Dics[1]))
G_plane_fr = filter.gs(vect(Dics[2]))
planes_fr = [E_plane_fr, S_plane_fr, G_plane_fr]

Dics = dics("en")
E_plane_en = filter.gs(vect(Dics[0]))
S_plane_en = filter.gs(vect(Dics[1]))
G_plane_en = filter.gs(vect(Dics[2]))
planes_en = [E_plane_fr, S_plane_fr, G_plane_fr]

def gs_esg(text:str, lang:str='en', threshold:float=0.722):
    if lang == "fr":
          E_plane = planes_fr[0]
          S_plane = planes_fr[1]
          G_plane = planes_fr[2]
    else:
          E_plane = planes_en[0]
          S_plane = planes_en[1]
          G_plane = planes_en[2] 
    label_dic = {
        'E': filter.forward(text, E_plane),
        'S': filter.forward(text, S_plane),
        'G': filter.forward(text, G_plane)
        }
    sort_orders = sorted(label_dic.items(), key=lambda x: x[1], reverse=True)
    if sort_orders[0][1]<threshold:
        return 'N'
    else:
        return sort_orders[0][0]