import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from typing import List

path = r"C:\Users\User\Desktop\Ahmad\Stages\SurfMetrics\Git\Flask\esg_topic\Data" + "/"

class Mean_model:
    def __init__(self, threshold: float):
      self.threshold = threshold
      self.ref = np.vstack([np.load(path+ "e_embeddings.npy"), 
                            np.load(path + "s_embeddings.npy"), 
                            np.load(path + "g_embeddings.npy")])

    def fit(self, embeddings: np.array) -> np.array:
        '''
        # Info 
        -----
        This Function calculates the similarity 
        between the text and each one of the
        three ESG categories

        # Parameters
        -----
        It only take a text parameter
        # Returns
        ----
        It returns a torch vector containing the 
        cosine similarity for earch of the three 
        categories
        '''

        y = cosine_similarity(embeddings, self.ref)
        l = [np.argmax(e) if np.max(e)>self.threshold else -1 for e in y]
        return l

class GS_model:
    def __init__(self, lang:str = "en", threshold:float = 0.7):
        self.lang = lang
        self.threshold = threshold
        self.e_orth = np.load(path + "e_orth_embeddings.npy")
        self.s_orth = np.load(path + "s_orth_embeddings.npy")
        self.g_orth = np.load(path + "g_orth_embeddings.npy")
        self.esg_orth = np.load(path + "esg_orth_embeddings.npy")

    def fit(self, embeddings: np.ndarray, mode:int = 0) -> np.ndarray:
        if mode == 0:
            l = []
            for a in embeddings:
                a1 = self._proj(a, self.e_orth)
                a2 = self._proj(a, self.s_orth)
                a3 = self._proj(a, self.g_orth)
                l+=[cosine_similarity(a.reshape(1,-1), np.vstack([a1, a2, a3]))]
            return [np.argmax(e) if np.max(e)>self.threshold else -1 for e in l]
        elif mode == 1:
            l = []
            for a in embeddings:
                a_F = self._proj(a, self.esg_orth)
                l+=[cosine_similarity(a.reshape(1,-1), a.reshape(1,-1))]
            return [1 if np.max(e)>self.threshold else -1 for e in l]

    def _proj(self, a: np.array, base: np.ndarray) -> np.ndarray:
        '''
        # Info
        ---
        This function will find the orthogonal projection of the
        vector generated by the word on the plane generated by our
        dictionnary.

        # Parameters
        ---
        It takes as parameters a string and the list of our orthonormalised
        base. 

        # Returns
        ---
        We get in return the orthogonal projetcion of a.
        '''

        a_F = np.zeros(len(a))
        for e in base:
            a_F = np.add(a_F, np.multiply((e@a),e))
        return a_F


class Finbert_model:

    def __init__(self, lang:str = "en"):

        from deep_translator import GoogleTranslator
        from transformers import pipeline, BertTokenizer, BertForSequenceClassification

        finbert = BertForSequenceClassification.from_pretrained('yiyanghkust/finbert-esg',num_labels=4)
        tokenizer = BertTokenizer.from_pretrained('yiyanghkust/finbert-esg')

        self.filter = pipeline("text-classification", model=finbert, tokenizer=tokenizer)
        self.lang = lang
    

    def fit(self, documents):
        l = self.filter(documents)
        result = []
        for t in l:
            if t['label']=="Environmental":
                result += [0]
            elif t['label']=="Social":
                result += [1]
            elif t['label']=="Governance":
                result += [2]
            else:
                result += [-1]
        print(result)
        return result

    # def fit_1(self, documents):
    #     l = []
    #     for text in documents:
    #         l += [self.finbert_esg(text)]
    #     return l

    # def finbert_esg(self, text:str) -> str:
    #         if self.lang=="en":
    #             return self.finbert_english(text)
    #         else:
    #             text_en = GoogleTranslator(source=self.lang, target="en").translate(text)
    #             return self.finbert_english(text_en)

    # def finbert_english(self, text:str) -> str:
    #     if self.filter(text)[0]['label']=="Environmental":
    #         return 0
    #     if self.filter(text)[0]['label']=="Social":
    #         return 1
    #     if self.filter(text)[0]['label']=="Governance":
    #         return 2
    #     return -1
